<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>ConcreteEdgesGraph.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">CircularOrbitHelper (1) (May 19, 2019 10:19:54 PM)</a> &gt; <a href="../../index.html" class="el_group">Lab4-1170300316</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">extensions</a> &gt; <span class="el_source">ConcreteEdgesGraph.java</span></div><h1>ConcreteEdgesGraph.java</h1><pre class="source lang-java linenums">/* Copyright (c) 2015-2016 MIT 6.005 course staff, all rights reserved.
 * Redistribution of original or derived work requires permission of course staff.
 */
package extensions;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


/**
 * An implementation of Graph.
 * 
 * &lt;p&gt;
 * PS2 instructions: you MUST use the provided rep.
 */
public class ConcreteEdgesGraph&lt;L&gt; implements Graph&lt;L&gt; {

<span class="fc" id="L22">	private final Set&lt;L&gt; vertices = new HashSet&lt;&gt;();</span>
<span class="fc" id="L23">	private final List&lt;Edge&gt; edges = new ArrayList&lt;&gt;();</span>

	// Abstraction function:
	// vertices + edges -&gt; Graph
	// Representation invariant:
	// Edge weights &gt;= 0
	// No two edges share the same source and target
	// edges is an ordered mutable list. Edge is an immutable type
	// vertices is a mutable set. L is immutable.
	// Safety from rep exposure:
	// fields are private and final
	// immutable data types

	// constructor
//	public ConcreteEdgesGraph() {
//		
//	}
//	
//	public ConcreteEdgesGraph(Set&lt;L&gt; vertices, List&lt;Edge&lt;L&gt;&gt; edges){
//        this.vertices.addAll(vertices);
//        this.edges.addAll(edges);
//    }
//	
//	public ConcreteEdgesGraph(List&lt;Edge&lt;L&gt;&gt; edges, Set&lt;L&gt; vertices){
//        this.vertices.addAll(vertices);
//        this.edges.addAll(edges);
//    }

<span class="fc" id="L51">	public ConcreteEdgesGraph(Set&lt;L&gt; vertices){</span>
<span class="fc" id="L52">        this.vertices.addAll(vertices);</span>
<span class="fc" id="L53">    }</span>

	@Override
	public boolean add(L vertex) {
		// TODO Auto-generated method stub
<span class="nc" id="L58">		return false;</span>
	}

	@Override
	public int set(L source, L target, int weight) {
		// TODO Auto-generated method stub
<span class="nc" id="L64">		return 0;</span>
	}

	@Override
	public boolean remove(L vertex) {
		// TODO Auto-generated method stub
<span class="nc" id="L70">		return false;</span>
	}

	@Override
	public Set&lt;L&gt; vertices() {
		// TODO Auto-generated method stub
<span class="nc" id="L76">		return null;</span>
	}

	@Override
	public Map&lt;L, Integer&gt; sources(L target) {
		// TODO Auto-generated method stub
<span class="nc" id="L82">		return null;</span>
	}

	@Override
	public Map&lt;L, Integer&gt; targets(L source) {
		// TODO Auto-generated method stub
<span class="nc" id="L88">		return null;</span>
	}
	
	// checkRep
	// The weight of each edge must be larger than 0 or equal to 0
//	private void checkRep() {
//		for (Edge edge : edges) {
//			assert edge.getWeight() &gt;= 0;
//		}
//	}
//
//	@Override
//	public boolean add(L vertex) {
//		return vertices.add(vertex);
//	}
//
//	@Override
//	public int set(L source, L target, int weight) {
//		Edge edgeToBeAdded = new Edge(source, target, weight);
//		for (Edge element : edges) {
//			// Update the weight if the edge has already existed.
//			if (element.sameEdge(edgeToBeAdded)) {
//				if (element.getWeight() != 0) {
//					if (edgeToBeAdded.getWeight() == 0) {
//						edges.remove(element);
//						return element.getWeight();
//					}
//
//					edges.remove(element);
//					edges.add(edgeToBeAdded);
//					return element.getWeight();
//				}
//			}
//		}
//		// The edge is totally new.
//		this.add(source);
//		this.add(target);
//		edges.add(edgeToBeAdded);
//		return 0;
//	}
//
//	@Override
//	public boolean remove(L vertex) {
//		if (!vertices.contains(vertex))
//			return false;
//		else {
//			int size = edges.size();
//			for (int i = 0; i &lt; size; i++) {
//				if (edges.get(i).getSource() == vertex || edges.get(i).getTarget() == vertex) {
//					System.out.println(&quot;Remove: &quot; + edges.get(i).getSource() + &quot; &quot; + edges.get(i).getTarget());
//					edges.remove(edges.get(i));
//					size--;
//				}
//			}
//			vertices.remove(vertex);
//			return true;
//		}
//	}
//
//	@Override
//	public Set&lt;L&gt; vertices() {
//		return vertices;
//	}
//
//	@Override
//	public Map&lt;L, Integer&gt; sources(L target) {
//		Map&lt;L, Integer&gt; resultMap = new HashMap&lt;L, Integer&gt;();
//		for (Edge element : edges) {
//			if (element.getTarget() == target) {
//				resultMap.put((L) element.getSource(), element.getWeight());
//			}
//		}
//		return resultMap;
//	}
//
//	@Override
//	public Map&lt;L, Integer&gt; targets(L source) {
//		Map&lt;L, Integer&gt; resultMap = new HashMap&lt;L, Integer&gt;();
//		for (Edge element : edges) {
//			if (element.getSource() == source) {
//				resultMap.put((L) element.getTarget(), element.getWeight());
//			}
//		}
//		return resultMap;
//	}
//
//	// TODO toString()
//	@Override
//	public String toString() {
//		return &quot;Vertices: &quot; + vertices + &quot;\nEdges: &quot; + edges;
//	}
//	
	
}

/**
 * TODO specification Immutable. This class is internal to the rep of
 * ConcreteEdgesGraph.
 * 
 * &lt;p&gt;
 * PS2 instructions: the specification and implementation of this class is up to
 * you.
 */


<span class="nc bnc" id="L193" title="All 2 branches missed.">class Edge&lt;L&gt; {</span>

	// TODO fields
	private final L source;
	private final L target;
	private final int weight;

	// Abstraction function:
	// source -&gt; source vertex of the edge
	// target -&gt; target point of the edge
	// weight -&gt; the weight of the edge

	// Representation invariant:
	// weight &gt;= 0

	// Safety from rep exposure:
	// Set the RIs to private final data type
	// Edge is set to be an immutable data type

	// TODO constructor
<span class="nc" id="L213">	public Edge(L startPoint, L endPoint, int weight) {</span>
<span class="nc" id="L214">		this.source = startPoint;</span>
<span class="nc" id="L215">		this.target = endPoint;</span>
<span class="nc" id="L216">		this.weight = weight;</span>
<span class="nc" id="L217">	}</span>

	// TODO checkRep
	private void checkRep() {
<span class="nc bnc" id="L221" title="All 4 branches missed.">		assert (weight &gt;= 0);</span>
<span class="nc" id="L222">	}</span>

	// TODO methods
	/**
	 * @return the weight of an edge
	 */
	public int getWeight() {
<span class="nc" id="L229">		return weight;</span>
	}

	/**
	 * @return the source vertex of an edge
	 */
	public L getSource() {
<span class="nc" id="L236">		return source;</span>
	}

	/**
	 * @return the target vertex of an edge
	 */
	public L getTarget() {
<span class="nc" id="L243">		return target;</span>
	}

	/**
	 * Judge if it is the same edge
	 * 
	 * @param Edge
	 * @return true for the same edge��false for the different edge
	 */
	public boolean sameEdge(Edge edge) {
<span class="nc bnc" id="L253" title="All 4 branches missed.">		if (edge.getSource() == this.source &amp;&amp; edge.getTarget() == this.target) {</span>
<span class="nc" id="L254">			return true;</span>
		}
<span class="nc" id="L256">		return false;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span>CircularOrbitHelper (1) (May 19, 2019 10:19:54 PM)</div></body></html>